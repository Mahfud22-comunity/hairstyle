<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FaceMesh Styler — Mediapipe Face Shape</title>

<!-- Mediapipe Face Mesh + drawing utils + camera utils -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

<style>
  :root{
    --bg1:#0f1724; --bg2:#10203a; --card: rgba(255,255,255,0.04);
    --accent:#00d4ff; --muted:#cbd5e1;
  }
  [data-theme="light"]{
    --bg1:#f6fafc; --bg2:#eef6fb; --card: rgba(0,0,0,0.04); --accent:#0ea5a5; --muted:#123;
  }

  *{box-sizing:border-box}
  body{
    margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial; color:var(--muted);
    background: linear-gradient(135deg,var(--bg1),var(--bg2));
    min-height:100vh; display:flex; align-items:center; justify-content:center; padding:28px;
  }

  .app{ width:100%; max-width:1100px; display:grid; grid-template-columns:1fr 360px; gap:20px; }

  .panel{ background:var(--card); border-radius:14px; padding:16px; backdrop-filter: blur(8px); box-shadow:0 8px 30px rgba(2,6,23,0.6); }

  header{ grid-column:1/-1; display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:6px; }
  h1{margin:0;font-size:18px}

  .controls{ display:flex; gap:8px; align-items:center;}
  .btn{ background:var(--accent); border:none; padding:8px 12px; border-radius:10px; color:#000; font-weight:700; cursor:pointer; }
  .btn.ghost{ background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.04); }
  .file-label{ padding:10px;border-radius:10px; border:2px dashed rgba(255,255,255,0.04); cursor:pointer; display:inline-block; }

  .stage{ display:flex; flex-direction:column; gap:12px; }
  .drop-area{ position:relative; border-radius:12px; padding:12px; min-height:420px; display:flex; align-items:center; justify-content:center; flex-direction:column; gap:10px; border:2px dashed rgba(255,255,255,0.04); }
  .drop-area.drag{ border-color: rgba(0,212,255,0.8); box-shadow:0 10px 40px rgba(0,212,255,0.06); }

  #preview{ max-width:100%; max-height:560px; border-radius:12px; display:block; object-fit:contain; }
  canvas#overlay{ position:absolute; left:12px; top:12px; pointer-events:auto; border-radius:12px; }

  .actions{ display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }

  .sidebar .card{ margin-bottom:12px; }

  .history-item{ display:flex; gap:8px; align-items:center; cursor:pointer; padding:6px; border-radius:8px; }
  .thumb{ width:56px; height:56px; object-fit:cover; border-radius:6px; border:1px solid rgba(255,255,255,0.03); }

  .loader{ width:36px; height:36px; border:4px solid rgba(255,255,255,0.08); border-top-color:var(--accent); border-radius:50%; animation:spin 1s linear infinite; margin:auto;}
  @keyframes spin{ to{transform:rotate(360deg)} }

  .face-badge{ position:absolute; background:var(--accent); color:#000; padding:6px 8px; border-radius:8px; font-weight:800; transform:translate(-50%,-140%); pointer-events:auto; cursor:pointer; }

  .result-card{ padding:10px; border-radius:10px; background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); }

  @media (max-width:980px){ .app{ grid-template-columns: 1fr; } .sidebar{ order:2 } }
</style>
</head>
<body data-theme="dark">

<div class="app">

  <header>
    <div>
      <h1>FaceMesh Styler (Mediapipe)</h1>
      <div style="font-size:13px;color:var(--muted)">Deteksi bentuk wajah — offline client-side setelah model di-cache</div>
    </div>

    <div class="controls">
      <button id="themeBtn" class="btn ghost">Toggle Theme</button>
      <button id="clearHistory" class="btn ghost">Clear History</button>
    </div>
  </header>

  <!-- left -->
  <section class="panel stage">
    <div class="card" style="display:flex;justify-content:space-between;align-items:center;">
      <div style="font-size:13px;color:var(--muted)">Model status: <span id="modelStatus" style="font-weight:700">Memuat...</span></div>
      <div style="display:flex;gap:8px;align-items:center">
        <label class="file-label">
          Pilih file
          <input id="fileInput" type="file" accept="image/*" style="display:none" />
        </label>
        <button id="webcamBtn" class="btn ghost">Buka Kamera</button>
        <button id="captureBtn" class="btn" style="display:none">Ambil Foto</button>
      </div>
    </div>

    <div id="drop" class="drop-area">
      <div id="dropHint" style="text-align:center">
        <div style="font-weight:700;color:var(--muted)">Seret & lepas foto di sini</div>
        <div style="font-size:13px;color:var(--muted);margin-top:6px">atau pilih file / gunakan kamera</div>
      </div>

      <img id="preview" alt="preview" style="display:none" />
      <canvas id="overlay" style="display:none"></canvas>

      <div id="processing" style="display:none">
        <div class="loader"></div>
        <div style="font-size:13px;color:var(--muted);margin-top:8px">Memproses...</div>
      </div>
    </div>

    <div class="actions">
      <button id="analyzeBtn" class="btn" disabled>Deteksi Ulang</button>
      <button id="downloadBtn" class="btn ghost" disabled>Download Hasil</button>
      <button id="saveBtn" class="btn" disabled>Simpan Riwayat</button>
    </div>

    <div id="resultPanel" class="result-card" style="display:none;margin-top:10px">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div style="font-size:13px;color:var(--muted)">Hasil:</div>
          <div id="shapeText" style="font-size:18px;font-weight:800;color:var(--muted)">-</div>
        </div>
        <div id="metricBox" style="text-align:right;font-size:13px;color:var(--muted)"></div>
      </div>
      <div style="margin-top:10px">
        <div style="font-size:13px;color:var(--muted)">Rekomendasi:</div>
        <ul id="recList"></ul>
      </div>
    </div>
  </section>

  <!-- right (sidebar) -->
  <aside class="panel sidebar">
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div style="font-size:13px;color:var(--muted);font-weight:700">Riwayat Analisis</div>
          <div style="font-size:12px;color:var(--muted)">Tersimpan di local</div>
        </div>
        <div id="historyCount" style="font-weight:700;color:var(--muted)">0</div>
      </div>

      <div id="historyList" style="margin-top:10px;max-height:420px;overflow:auto"></div>
    </div>

    <div class="card" style="margin-top:12px">
      <div style="font-size:13px;color:var(--muted);font-weight:700">Petunjuk</div>
      <ol style="font-size:13px;color:var(--muted);margin-top:8px;padding-left:18px">
        <li>Gunakan foto frontal (wajah menghadap kamera).</li>
        <li>Jika ada beberapa wajah, klik badge di atas foto untuk memilih.</li>
        <li>Simpan hasil jika ingin melihat kembali.</li>
      </ol>
    </div>
  </aside>

</div>

<!-- hidden video for webcam -->
<video id="video" autoplay playsinline style="display:none"></video>

<script>
/* =========================
   FaceMesh Styler (Mediapipe)
   - Upload/Drag&Drop
   - Webcam capture
   - Multi-face detection
   - Draw mesh & bounding box
   - Compute simple heuristics to decide face shape
   - Save history (localStorage)
   ========================= */

const preview = document.getElementById('preview');
const overlay = document.getElementById('overlay');
const drop = document.getElementById('drop');
const dropHint = document.getElementById('dropHint');
const processing = document.getElementById('processing');
const modelStatus = document.getElementById('modelStatus');
const analyzeBtn = document.getElementById('analyzeBtn');
const downloadBtn = document.getElementById('downloadBtn');
const saveBtn = document.getElementById('saveBtn');
const resultPanel = document.getElementById('resultPanel');
const shapeText = document.getElementById('shapeText');
const recList = document.getElementById('recList');
const metricBox = document.getElementById('metricBox');
const fileInput = document.getElementById('fileInput');
const historyList = document.getElementById('historyList');
const historyCount = document.getElementById('historyCount');

const video = document.getElementById('video');
const webcamBtn = document.getElementById('webcamBtn');
const captureBtn = document.getElementById('captureBtn');

let faceMesh = null;
let cameraInstance = null;
let detections = []; // {box:{x,y,w,h}, landmarks: [ {x,y,z} ... ] }
let selectedFace = 0;
let currentImageSrc = null;
let history = loadHistory();

/* Recommendation map */
const RECO = {
  "Oval": ["Shaggy Cut","Pixie Cut","Bob","Layered Cut"],
  "Bulat": ["Layer Panjang","Side Part","Curtain Bang","Long Waves"],
  "Kotak": ["Soft Layer","Wavy Medium","Side Bob","Feathered Cut"],
  "Heart": ["Chin-Length Bob","Side Sweep","Long Curl","Soft Pixie"],
  "Diamond": ["Medium Layer","Curly Bob","Shag Soft","Side Bangs"],
  "Oblong": ["Side Fringe","Layered Long","Medium Waves","Curtain Style"]
};

/* --- Utility --- */
function showProcessing(flag){
  processing.style.display = flag ? "flex" : "none";
}
function showOverlay(flag){
  overlay.style.display = flag ? "block" : "none";
}
function clearCanvas(){
  const ctx = overlay.getContext('2d');
  ctx.clearRect(0,0,overlay.width,overlay.height);
  document.querySelectorAll('.face-badge').forEach(n=>n.remove());
}

/* Fit overlay canvas to displayed image size */
function fitCanvas(){
  overlay.width = preview.naturalWidth || preview.width;
  overlay.height = preview.naturalHeight || preview.height;
  overlay.style.width = preview.clientWidth + 'px';
  overlay.style.height = preview.clientHeight + 'px';
  // position relative handled by parent (overlay is absolute positioned inside drop area)
}

/* map normalized mediapipe coords to natural px */
function toNaturalPoint(pt){
  return { x: pt.x * (overlay.width), y: pt.y * (overlay.height), z: pt.z };
}

/* draw detections */
function drawAll(){
  if(!preview.src) return;
  fitCanvas();
  const ctx = overlay.getContext('2d');
  ctx.clearRect(0,0,overlay.width,overlay.height);

  detections.forEach((d,i) => {
    const box = d.box;
    // box in natural px
    ctx.lineWidth = (i===selectedFace)?6:3;
    ctx.strokeStyle = (i===selectedFace)?'rgba(0,212,255,0.95)':'rgba(255,255,255,0.45)';
    ctx.fillStyle = (i===selectedFace)?'rgba(0,212,255,0.06)':'rgba(255,255,255,0.02)';
    ctx.beginPath();
    ctx.rect(box.x, box.y, box.width, box.height);
    ctx.fill();
    ctx.stroke();

    // draw mesh for selected face
    if(i===selectedFace){
      // draw some face landmarks
      ctx.fillStyle = 'rgba(0,212,255,0.06)';
      ctx.strokeStyle = 'rgba(0,212,255,0.25)';
      d.landmarks.forEach(p => {
        // small circle
        ctx.beginPath();
        ctx.arc(p.x, p.y, 1.2, 0, Math.PI*2);
        ctx.fill();
      });
    }

    // add clickable badge label above box (DOM element)
    const existing = document.getElementById('badge-'+i);
    if(!existing){
      const badge = document.createElement('div');
      badge.className = 'face-badge';
      badge.id = 'badge-'+i;
      badge.innerText = `Face ${i+1}`;
      // position relative to preview DOM position
      // compute display coords
      const rect = preview.getBoundingClientRect();
      const scaleX = preview.clientWidth / preview.naturalWidth;
      const scaleY = preview.clientHeight / preview.naturalHeight;
      const left = rect.left + (box.x * scaleX) + (box.width * scaleX)/2;
      const top = rect.top + (box.y * scaleY);
      badge.style.left = left + 'px';
      badge.style.top = top + 'px';
      document.body.appendChild(badge);
      badge.addEventListener('click', ()=>{ selectedFace = i; showResultFor(i); drawAll(); });
    } else {
      // reposition existing
      const rect = preview.getBoundingClientRect();
      const scaleX = preview.clientWidth / preview.naturalWidth;
      const scaleY = preview.clientHeight / preview.naturalHeight;
      existing.style.left = (rect.left + (box.x * scaleX) + (box.width * scaleX)/2) + 'px';
      existing.style.top = (rect.top + (box.y * scaleY)) + 'px';
    }
  });

  // remove extra badges if less faces than before
  document.querySelectorAll('.face-badge').forEach(el=>{
    const id = el.id;
    const idx = parseInt(id.split('-')[1]);
    if(idx >= detections.length) el.remove();
  });
}

/* --- Face shape heuristics ---
   Using Mediapipe 468 landmarks. We'll use some well-known indices:
   - Chin (152)
   - Left cheek (~234)
   - Right cheek (~454)
   - Jaw left (~127), jaw right (~356)
   - Forehead approx: average of points near eyebrows (10 and 338/  'upper' points). We'll use point 10 (approx forehead near hairline)
   These heuristics are approximate and work well for frontal photos.
*/
function computeMetrics(landmarks){
  // landmarks is array of {x:..., y:..., z:...} in natural px
  const idx = (i) => landmarks[i];
  const chin = idx(152);
  const leftCheek = idx(234);
  const rightCheek = idx(454);
  const jawLeft = idx(127);
  const jawRight = idx(356);
  // point 10 is near center forehead
  const forehead = idx(10);

  const faceWidth = distance(leftCheek, rightCheek);
  const jawWidth = distance(jawLeft, jawRight);
  const faceHeight = distance(forehead, chin);

  return { faceWidth, jawWidth, faceHeight, chin, forehead };
}

function distance(a,b){
  return Math.hypot(a.x - b.x, a.y - b.y);
}

function decideShape(metrics){
  const {faceWidth, jawWidth, faceHeight} = metrics;
  const h_w = faceHeight / faceWidth;
  // tune thresholds (empirical)
  if(h_w > 1.5) return "Oblong";
  if(Math.abs(faceWidth - jawWidth) < Math.max(12, faceWidth*0.08)) return "Kotak";
  if(jawWidth < faceWidth * 0.78) return "Heart";
  if(faceWidth > jawWidth * 1.28) return "Diamond";
  if(faceWidth / faceHeight > 0.96) return "Bulat";
  return "Oval";
}

/* show result for a selected face index */
function showResultFor(i){
  if(!detections[i]) return;
  const metrics = computeMetrics(detections[i].landmarks);
  const shape = decideShape(metrics);
  shapeText.innerText = shape;
  metricBox.innerHTML = `Rasio H/W: ${(metrics.faceHeight/metrics.faceWidth).toFixed(2)}`;
  recList.innerHTML = '';
  (RECO[shape] || []).forEach(r=>{
    const li = document.createElement('li'); li.innerText = r; recList.appendChild(li);
  });
  resultPanel.style.display = 'block';
  downloadBtn.disabled = false;
  saveBtn.disabled = false;
}

/* --- Handlers for mediapipe results --- */
function onResults(results){
  // results.multiFaceLandmarks: array of landmarks in normalized coords (x,y in [0..1]) relative to image
  // results.image is the input image (HTMLImageElement/HTMLVideoElement/HTMLCanvasElement)
  clearCanvas();
  detections = [];
  if(!results.multiFaceLandmarks || results.multiFaceLandmarks.length===0){
    showProcessing(false); drawAll(); return;
  }

  // prepare overlay dimensions based on natural size of input image
  // set overlay to input natural size
  // results.image may be preview image element passed; we'll assume preview has naturalWidth/naturalHeight
  fitCanvas();

  // convert normalized to natural px coords and make bounding box
  results.multiFaceLandmarks.forEach(landArr => {
    const pts = landArr.map(p => toNaturalPoint(p));
    // compute bounding box
    const xs = pts.map(p=>p.x), ys = pts.map(p=>p.y);
    const minX = Math.min(...xs), maxX = Math.max(...xs);
    const minY = Math.min(...ys), maxY = Math.max(...ys);
    const box = { x: minX, y: minY, width: (maxX - minX), height: (maxY - minY) };
    detections.push({ box, landmarks: pts });
  });

  // default select first face if new
  selectedFace = 0;
  drawAll();
  showProcessing(false);
  showResultFor(selectedFace);
}

/* --- Initialize Mediapipe FaceMesh --- */
async function initFaceMesh(){
  modelStatus.innerText = "Memuat model FaceMesh...";
  faceMesh = new FaceMesh({
    locateFile: (file) => {
      // Mediapipe will fetch model files from CDN automatically
      return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
    }
  });
  faceMesh.setOptions({
    maxNumFaces: 4,
    refineLandmarks: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });
  faceMesh.onResults(onResults);
  modelStatus.innerText = "Model siap ✅";
}
initFaceMesh();

/* --- File & drag/drop handlers --- */
fileInput.addEventListener('change', async (e)=>{
  const f = e.target.files && e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  await loadImage(url);
});

drop.addEventListener('dragover', e=>{ e.preventDefault(); drop.classList.add('drag'); });
drop.addEventListener('dragleave', e=>{ e.preventDefault(); drop.classList.remove('drag'); });
drop.addEventListener('drop', async (e)=>{
  e.preventDefault(); drop.classList.remove('drag');
  const f = e.dataTransfer.files && e.dataTransfer.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  await loadImage(url);
});

/* load image into preview and run faceMesh */
async function loadImage(src){
  // reset
  clearCanvas(); resultPanel.style.display = 'none';
  showProcessing(true);
  preview.style.display = 'none';
  // remove existing badges
  document.querySelectorAll('.face-badge').forEach(n=>n.remove());

  const img = new Image();
  img.crossOrigin = "anonymous";
  img.onload = async ()=>{
    preview.src = src;
    currentImageSrc = src;
    // wait image DOM updates
    preview.style.display = 'block';
    // ensure overlay sizing (after image rendered)
    await new Promise(r => setTimeout(r, 120));
    fitCanvas();
    showOverlay(true);
    // send the image element to FaceMesh
    await faceMesh.send({image: preview});
  };
  img.onerror = ()=>{
    showProcessing(false);
    alert('Gagal memuat gambar.');
  };
  img.src = src;
}

/* --- Webcam support --- */
let streamRef = null;
webcamBtn.addEventListener('click', async ()=>{
  if(streamRef){
    // stop camera
    streamRef.getTracks().forEach(t=>t.stop()); streamRef=null; video.style.display='none'; captureBtn.style.display='none'; webcamBtn.innerText='Buka Kamera';
    return;
  }
  try{
    streamRef = await navigator.mediaDevices.getUserMedia({video:{facingMode:'user'}, audio:false});
    video.srcObject = streamRef;
    video.style.display = 'block';
    captureBtn.style.display = 'inline-block';
    webcamBtn.innerText = 'Tutup Kamera';
    // optionally preview video inside drop area when wanted
    // We'll capture still when user clicks capture
  } catch(err){
    alert('Tidak dapat mengakses kamera: ' + err.message);
  }
});

captureBtn.addEventListener('click', async ()=>{
  // capture a frame from video to canvas then load as image
  const c = document.createElement('canvas');
  c.width = video.videoWidth; c.height = video.videoHeight;
  const ctx = c.getContext('2d'); ctx.drawImage(video,0,0,c.width,c.height);
  const data = c.toDataURL('image/png');
  // stop camera
  if(streamRef){ streamRef.getTracks().forEach(t=>t.stop()); streamRef=null; video.style.display='none'; captureBtn.style.display='none'; webcamBtn.innerText='Buka Kamera'; }
  await loadImage(data);
});

/* --- analyze / re-run button --- */
analyzeBtn.addEventListener('click', async ()=>{
  if(!preview.src) return;
  showProcessing(true);
  // re-run faceMesh on preview
  await faceMesh.send({image: preview});
});

/* --- download result --- */
downloadBtn.addEventListener('click', ()=>{
  if(!preview.src || detections.length===0) return alert('Tidak ada hasil untuk diunduh');
  // create canvas with natural size and draw image + boxes + text
  const c = document.createElement('canvas');
  c.width = preview.naturalWidth; c.height = preview.naturalHeight;
  const ctx = c.getContext('2d');
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = ()=>{
    ctx.drawImage(img,0,0,c.width,c.height);
    // draw boxes
    ctx.lineWidth = 6; ctx.strokeStyle = 'rgba(0,212,255,0.9)'; ctx.fillStyle='rgba(0,212,255,0.06)';
    detections.forEach((d,i)=>{
      const b = d.box;
      ctx.beginPath(); ctx.rect(b.x,b.y,b.width,b.height); ctx.fill(); ctx.stroke();
      ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(b.x, b.y-30, 120, 28);
      ctx.fillStyle = '#00f0ff'; ctx.font = '20px sans-serif'; ctx.fillText(`Face ${i+1}`, b.x+6, b.y-8);
      ctx.fillStyle='rgba(0,212,255,0.06)';
    });
    // write result text
    ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, c.height-110, c.width, 110);
    ctx.fillStyle = '#fff'; ctx.font='26px sans-serif'; ctx.fillText('FaceMesh Styler — Hasil', 18, c.height-72);
    ctx.font='20px sans-serif'; ctx.fillText(shapeText.innerText || '-', 18, c.height-44);

    const link = document.createElement('a'); link.download = `faceshape_${Date.now()}.png`; link.href = c.toDataURL('image/png'); link.click();
  };
  img.src = preview.src;
});

/* --- Save to history (localStorage) --- */
saveBtn.addEventListener('click', ()=>{
  if(!preview.src) return;
  const ent = { id: Date.now(), date: new Date().toISOString(), image: preview.src, shape: shapeText.innerText || '-', rec: Array.from(recList.querySelectorAll('li')).map(x=>x.innerText) };
  history.unshift(ent); if(history.length>40) history.pop();
  localStorage.setItem('faceshape_mediapipe_history_v1', JSON.stringify(history));
  renderHistory();
  alert('Disimpan ke riwayat lokal.');
});

/* load history */
function loadHistory(){
  try{ const j = localStorage.getItem('faceshape_mediapipe_history_v1'); return j?JSON.parse(j):[]; }catch(e){ return []; }
}
function renderHistory(){
  historyList.innerHTML=''; historyCount.innerText = history.length;
  history.forEach(h=>{
    const row = document.createElement('div'); row.className='history-item';
    row.innerHTML = `<img class="thumb" src="${h.image}"><div style="flex:1"><div style="font-weight:700;color:var(--muted)">${h.shape}</div><div style="font-size:12px;color:var(--muted)">${new Date(h.date).toLocaleString()}</div></div>`;
    row.addEventListener('click', ()=> loadImage(h.image) );
    historyList.appendChild(row);
  });
}
renderHistory();

/* clear history */
document.getElementById('clearHistory').addEventListener('click', ()=>{
  if(confirm('Hapus semua riwayat?')){ history=[]; localStorage.removeItem('faceshape_mediapipe_history_v1'); renderHistory(); }
});

/* theme toggle */
document.getElementById('themeBtn').addEventListener('click', ()=>{
  const b = document.body; b.setAttribute('data-theme', b.getAttribute('data-theme') === 'dark' ? 'light' : 'dark');
});

/* cleanup badges on resize/scroll to reposition */
window.addEventListener('resize', ()=> drawAll());
window.addEventListener('scroll', ()=> drawAll());

/* --- small helper: when faceMesh outputs results, it triggers onResults which calls drawAll & showResultFor --- */
/* We already set faceMesh.onResults earlier via initFaceMesh. But Mediapipe's FaceMesh requires an input pipeline.
   We call faceMesh.send({image: preview}) after loading an image.
*/

/* show initial state */
showProcessing(false);
showOverlay(false);
modelStatus.innerText = 'Inisialisasi...';

// Wait until FaceMesh instance is ready
// (initFaceMesh sets up faceMesh and onResults earlier)
setTimeout(()=>{
  if(faceMesh) modelStatus.innerText = 'Model siap ✅';
  else modelStatus.innerText = 'Model belum siap';
}, 800);

/* small safety: when preview is clicked, toggle drawing to allow selecting image area */
preview.addEventListener('load', ()=> {
  // remove previous badges
  document.querySelectorAll('.face-badge').forEach(n=>n.remove());
  // fit overlay size and position (overlay is absolutely positioned inside drop area, so compute offset)
  // place overlay at top-left inside drop area
  const rect = drop.getBoundingClientRect();
  overlay.style.left = '12px'; overlay.style.top = '12px';
  overlay.style.position = 'absolute';
  // set overlay DOM size to match image natural size and display scaled
  fitCanvas();
});

/* remove badges when leaving page */
window.addEventListener('beforeunload', ()=>{
  document.querySelectorAll('.face-badge').forEach(n=>n.remove());
});
</script>
</body>
</html>
